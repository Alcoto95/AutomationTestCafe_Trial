"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const lodash_1 = require("lodash");
const os_family_1 = __importDefault(require("os-family"));
const api_based_1 = __importDefault(require("../../api-based"));
const compiler_1 = __importDefault(require("../es-next/compiler"));
const typescript_configuration_1 = __importDefault(require("../../../../configuration/typescript-configuration"));
const RENAMED_DEPENDENCIES_MAP = new Map([['testcafe', api_based_1.default.EXPORTABLE_LIB_PATH]]);
const tsDefsPath = path_1.default.resolve(__dirname, '../../../../../ts-defs/index.d.ts');
class TypeScriptTestFileCompiler extends api_based_1.default {
    constructor({ typeScriptOptions } = {}) {
        super();
        const tsConfigPath = typeScriptOptions ? typeScriptOptions.tsConfigPath : null;
        this.tsConfig = new typescript_configuration_1.default(tsConfigPath);
    }
    static _reportErrors(diagnostics) {
        // NOTE: lazy load the compiler
        const ts = require('typescript');
        let errMsg = 'TypeScript compilation failed.\n';
        diagnostics.forEach(d => {
            const message = ts.flattenDiagnosticMessageText(d.messageText, '\n');
            const file = d.file;
            if (file) {
                const { line, character } = file.getLineAndCharacterOfPosition(d.start);
                errMsg += `${file.fileName} (${line + 1}, ${character + 1}): `;
            }
            errMsg += `${message}\n`;
        });
        throw new Error(errMsg);
    }
    static _normalizeFilename(filename) {
        filename = path_1.default.resolve(filename);
        if (os_family_1.default.win)
            filename = filename.toLowerCase();
        return filename;
    }
    _compileCodeForTestFiles(testFilesInfo) {
        return this.tsConfig.init()
            .then(() => {
            return super._compileCodeForTestFiles(testFilesInfo);
        });
    }
    _precompileCode(testFilesInfo) {
        // NOTE: lazy load the compiler
        const ts = require('typescript');
        const filenames = testFilesInfo.map(({ filename }) => filename).concat([tsDefsPath]);
        const normalizedFilenames = filenames.map(filename => TypeScriptTestFileCompiler._normalizeFilename(filename));
        const normalizedFilenamesMap = lodash_1.zipObject(normalizedFilenames, filenames);
        const uncachedFiles = normalizedFilenames
            .filter(filename => !this.cache[filename])
            .map(filename => normalizedFilenamesMap[filename]);
        const opts = this.tsConfig.getOptions();
        const program = ts.createProgram(uncachedFiles, opts);
        program.getSourceFiles().forEach(sourceFile => {
            sourceFile.renamedDependencies = RENAMED_DEPENDENCIES_MAP;
        });
        const diagnostics = ts.getPreEmitDiagnostics(program);
        if (diagnostics.length)
            TypeScriptTestFileCompiler._reportErrors(diagnostics);
        // NOTE: The first argument of emit() is a source file to be compiled. If it's undefined, all files in
        // <program> will be compiled. <program> contains a file specified in createProgram() plus all its dependencies.
        // This mode is much faster than compiling files one-by-one, and it is used in the tsc CLI compiler.
        program.emit(void 0, (outputName, result, writeBOM, onError, sources) => {
            const sourcePath = TypeScriptTestFileCompiler._normalizeFilename(sources[0].fileName);
            this.cache[sourcePath] = result;
        });
        return normalizedFilenames.map(filename => this.cache[filename]);
    }
    _getRequireCompilers() {
        return {
            '.ts': (code, filename) => this._compileCode(code, filename),
            '.js': (code, filename) => compiler_1.default.prototype._compileCode.call(this, code, filename)
        };
    }
    get canPrecompile() {
        return true;
    }
    getSupportedExtension() {
        return '.ts';
    }
}
exports.default = TypeScriptTestFileCompiler;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvY29tcGlsZXIvdGVzdC1maWxlL2Zvcm1hdHMvdHlwZXNjcmlwdC9jb21waWxlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGdEQUF3QjtBQUN4QixtQ0FBbUM7QUFDbkMsMERBQTJCO0FBQzNCLGdFQUEyRDtBQUMzRCxtRUFBeUQ7QUFDekQsa0hBQXlGO0FBRXpGLE1BQU0sd0JBQXdCLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLFVBQVUsRUFBRSxtQkFBNEIsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMzRyxNQUFNLFVBQVUsR0FBaUIsY0FBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsbUNBQW1DLENBQUMsQ0FBQztBQUU5RixNQUFxQiwwQkFBMkIsU0FBUSxtQkFBNEI7SUFDaEYsWUFBYSxFQUFFLGlCQUFpQixFQUFFLEdBQUcsRUFBRTtRQUNuQyxLQUFLLEVBQUUsQ0FBQztRQUVSLE1BQU0sWUFBWSxHQUFHLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztRQUUvRSxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksa0NBQXVCLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDOUQsQ0FBQztJQUVELE1BQU0sQ0FBQyxhQUFhLENBQUUsV0FBVztRQUM3QiwrQkFBK0I7UUFDL0IsTUFBTSxFQUFFLEdBQU8sT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ3JDLElBQUksTUFBTSxHQUFHLGtDQUFrQyxDQUFDO1FBRWhELFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDcEIsTUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDLDRCQUE0QixDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDckUsTUFBTSxJ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QUMsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUV0RixJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxHQUFHLE1BQU0sQ0FBQztRQUNwQyxDQUFDLENBQUMsQ0FBQztRQUVILE9BQU8sbUJBQW1CLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQ3JFLENBQUM7SUFFRCxvQkFBb0I7UUFDaEIsT0FBTztZQUNILEtBQUssRUFBRSxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQztZQUM1RCxLQUFLLEVBQUUsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLEVBQUUsQ0FBQyxrQkFBc0IsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLFFBQVEsQ0FBQztTQUN0RyxDQUFDO0lBQ04sQ0FBQztJQUVELElBQUksYUFBYTtRQUNiLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFRCxxQkFBcUI7UUFDakIsT0FBTyxLQUFLLENBQUM7SUFDakIsQ0FBQztDQUNKO0FBaEdELDZDQWdHQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgemlwT2JqZWN0IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBPUyBmcm9tICdvcy1mYW1pbHknO1xuaW1wb3J0IEFQSUJhc2VkVGVzdEZpbGVDb21waWxlckJhc2UgZnJvbSAnLi4vLi4vYXBpLWJhc2VkJztcbmltcG9ydCBFU05leHRUZXN0RmlsZUNvbXBpbGVyIGZyb20gJy4uL2VzLW5leHQvY29tcGlsZXInO1xuaW1wb3J0IFR5cGVzY3JpcHRDb25maWd1cmF0aW9uIGZyb20gJy4uLy4uLy4uLy4uL2NvbmZpZ3VyYXRpb24vdHlwZXNjcmlwdC1jb25maWd1cmF0aW9uJztcblxuY29uc3QgUkVOQU1FRF9ERVBFTkRFTkNJRVNfTUFQID0gbmV3IE1hcChbWyd0ZXN0Y2FmZScsIEFQSUJhc2VkVGVzdEZpbGVDb21waWxlckJhc2UuRVhQT1JUQUJMRV9MSUJfUEFUSF1dKTtcbmNvbnN0IHRzRGVmc1BhdGggICAgICAgICAgICAgICA9IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuLi8uLi8uLi8uLi8uLi90cy1kZWZzL2luZGV4LmQudHMnKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHlwZVNjcmlwdFRlc3RGaWxlQ29tcGlsZXIgZXh0ZW5kcyBBUElCYXNlZFRlc3RGaWxlQ29tcGlsZXJCYXNlIHtcbiAgICBjb25zdHJ1Y3RvciAoeyB0eXBlU2NyaXB0T3B0aW9ucyB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBjb25zdCB0c0NvbmZpZ1BhdGggPSB0eXBlU2NyaXB0T3B0aW9ucyA/IHR5cGVTY3JpcHRPcHRpb25zLnRzQ29uZmlnUGF0aCA6IG51bGw7XG5cbiAgICAgICAgdGhpcy50c0NvbmZpZyA9IG5ldyBUeXBlc2NyaXB0Q29uZmlndXJhdGlvbih0c0NvbmZpZ1BhdGgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBfcmVwb3J0RXJyb3JzIChkaWFnbm9zdGljcykge1xuICAgICAgICAvLyBOT1RFOiBsYXp5IGxvYWQgdGhlIGNvbXBpbGVyXG4gICAgICAgIGNvbnN0IHRzICAgICA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQnKTtcbiAgICAgICAgbGV0IGVyck1zZyA9ICdUeXBlU2NyaXB0IGNvbXBpbGF0aW9uIGZhaWxlZC5cXG4nO1xuXG4gICAgICAgIGRpYWdub3N0aWNzLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdHMuZmxhdHRlbkRpYWdub3N0aWNNZXNzYWdlVGV4dChkLm1lc3NhZ2VUZXh0LCAnXFxuJyk7XG4gICAgICAgICAgICBjb25zdCBmaWxlICAgID0gZC5maWxlO1xuXG4gICAgICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGluZSwgY2hhcmFjdGVyIH0gPSBmaWxlLmdldExpbmVBbmRDaGFyYWN0ZXJPZlBvc2l0aW9uKGQuc3RhcnQpO1xuXG4gICAgICAgICAgICAgICAgZXJyTXNnICs9IGAke2ZpbGUuZmlsZU5hbWV9ICgke2xpbmUgKyAxfSwgJHtjaGFyYWN0ZXIgKyAxfSk6IGA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVyck1zZyArPSBgJHttZXNzYWdlfVxcbmA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgIH1cblxuICAgIHN0YXRpYyBfbm9ybWFsaXplRmlsZW5hbWUgKGZpbGVuYW1lKSB7XG4gICAgICAgIGZpbGVuYW1lID0gcGF0aC5yZXNvbHZlKGZpbGVuYW1lKTtcblxuICAgICAgICBpZiAoT1Mud2luKVxuICAgICAgICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIHJldHVybiBmaWxlbmFtZTtcbiAgICB9XG5cbiAgICBfY29tcGlsZUNvZGVGb3JUZXN0RmlsZXMgKHRlc3RGaWxlc0luZm8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHNDb25maWcuaW5pdCgpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyLl9jb21waWxlQ29kZUZvclRlc3RGaWxlcyh0ZXN0RmlsZXNJbmZvKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9wcmVjb21waWxlQ29kZSAodGVzdEZpbGVzSW5mbykge1xuICAgICAgICAvLyBOT1RFOiBsYXp5IGxvYWQgdGhlIGNvbXBpbGVyXG4gICAgICAgIGNvbnN0IHRzID0gcmVxdWlyZSgndHlwZXNjcmlwdCcpO1xuXG4gICAgICAgIGNvbnN0IGZpbGVuYW1lcyAgICAgICAgICAgICAgPSB0ZXN0RmlsZXNJbmZvLm1hcCgoeyBmaWxlbmFtZSB9KSA9PiBmaWxlbmFtZSkuY29uY2F0KFt0c0RlZnNQYXRoXSk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGaWxlbmFtZXMgICAgPSBmaWxlbmFtZXMubWFwKGZpbGVuYW1lID0+IFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLl9ub3JtYWxpemVGaWxlbmFtZShmaWxlbmFtZSkpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkRmlsZW5hbWVzTWFwID0gemlwT2JqZWN0KG5vcm1hbGl6ZWRGaWxlbmFtZXMsIGZpbGVuYW1lcyk7XG5cbiAgICAgICAgY29uc3QgdW5jYWNoZWRGaWxlcyA9IG5vcm1hbGl6ZWRGaWxlbmFtZXNcbiAgICAgICAgICAgIC5maWx0ZXIoZmlsZW5hbWUgPT4gIXRoaXMuY2FjaGVbZmlsZW5hbWVdKVxuICAgICAgICAgICAgLm1hcChmaWxlbmFtZSA9PiBub3JtYWxpemVkRmlsZW5hbWVzTWFwW2ZpbGVuYW1lXSk7XG5cbiAgICAgICAgY29uc3Qgb3B0cyAgICA9IHRoaXMudHNDb25maWcuZ2V0T3B0aW9ucygpO1xuICAgICAgICBjb25zdCBwcm9ncmFtID0gdHMuY3JlYXRlUHJvZ3JhbSh1bmNhY2hlZEZpbGVzLCBvcHRzKTtcblxuICAgICAgICBwcm9ncmFtLmdldFNvdXJjZUZpbGVzKCkuZm9yRWFjaChzb3VyY2VGaWxlID0+IHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGUucmVuYW1lZERlcGVuZGVuY2llcyA9IFJFTkFNRURfREVQRU5ERU5DSUVTX01BUDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZGlhZ25vc3RpY3MgPSB0cy5nZXRQcmVFbWl0RGlhZ25vc3RpY3MocHJvZ3JhbSk7XG5cbiAgICAgICAgaWYgKGRpYWdub3N0aWNzLmxlbmd0aClcbiAgICAgICAgICAgIFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLl9yZXBvcnRFcnJvcnMoZGlhZ25vc3RpY3MpO1xuXG4gICAgICAgIC8vIE5PVEU6IFRoZSBmaXJzdCBhcmd1bWVudCBvZiBlbWl0KCkgaXMgYSBzb3VyY2UgZmlsZSB0byBiZSBjb21waWxlZC4gSWYgaXQncyB1bmRlZmluZWQsIGFsbCBmaWxlcyBpblxuICAgICAgICAvLyA8cHJvZ3JhbT4gd2lsbCBiZSBjb21waWxlZC4gPHByb2dyYW0+IGNvbnRhaW5zIGEgZmlsZSBzcGVjaWZpZWQgaW4gY3JlYXRlUHJvZ3JhbSgpIHBsdXMgYWxsIGl0cyBkZXBlbmRlbmNpZXMuXG4gICAgICAgIC8vIFRoaXMgbW9kZSBpcyBtdWNoIGZhc3RlciB0aGFuIGNvbXBpbGluZyBmaWxlcyBvbmUtYnktb25lLCBhbmQgaXQgaXMgdXNlZCBpbiB0aGUgdHNjIENMSSBjb21waWxlci5cbiAgICAgICAgcHJvZ3JhbS5lbWl0KHZvaWQgMCwgKG91dHB1dE5hbWUsIHJlc3VsdCwgd3JpdGVCT00sIG9uRXJyb3IsIHNvdXJjZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVBhdGggPSBUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlci5fbm9ybWFsaXplRmlsZW5hbWUoc291cmNlc1swXS5maWxlTmFtZSk7XG5cbiAgICAgICAgICAgIHRoaXMuY2FjaGVbc291cmNlUGF0aF0gPSByZXN1bHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkRmlsZW5hbWVzLm1hcChmaWxlbmFtZSA9PiB0aGlzLmNhY2hlW2ZpbGVuYW1lXSk7XG4gICAgfVxuXG4gICAgX2dldFJlcXVpcmVDb21waWxlcnMgKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJy50cyc6IChjb2RlLCBmaWxlbmFtZSkgPT4gdGhpcy5fY29tcGlsZUNvZGUoY29kZSwgZmlsZW5hbWUpLFxuICAgICAgICAgICAgJy5qcyc6IChjb2RlLCBmaWxlbmFtZSkgPT4gRVNOZXh0VGVzdEZpbGVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVDb2RlLmNhbGwodGhpcywgY29kZSwgZmlsZW5hbWUpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZ2V0IGNhblByZWNvbXBpbGUgKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBnZXRTdXBwb3J0ZWRFeHRlbnNpb24gKCkge1xuICAgICAgICByZXR1cm4gJy50cyc7XG4gICAgfVxufVxuIl19